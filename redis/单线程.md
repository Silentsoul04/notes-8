- 使用单线程模型能带来更好的可维护性，方便开发和调试；
- 使用单线程模型也能并发的处理客户端的请求；
- Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；



## 并发处理
使用单线程模型也**并不意味着程序不能并发的处理任务**，Redis 虽然使用单线程模型处理用户的请求，但是它却使用**I/O 多路复用机制**并发处理来自客户端的多个连接，**同时等待多个连接发送的请求**。

在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够**同时监控多个文件描述符**（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。

使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要**额外创建和维护进程和线程**来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。

简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作**都会在内存中**完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于**网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O**，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。

频繁的对线程的**上下文进行切换**可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。

## 总结
Redis 选择使用单线程模型处理客户端的请求主要还是因为**CPU 不是 Redis 服务器的瓶颈**，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在**网络 I/O 操作上**；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些**大键值对的删除操作**，通过多线程非阻塞地释放内存空间也能**减少**对 Redis**主线程阻塞**的时间，提高执行的效率。

> 引入 IO 多路复用可以同时监听多个连接的可读和可写，不需要多个线程来做这个事情，引入了不必要的复杂性


Q: 看了这篇文章，说到Redis6.0引入了多线程，是为了解决网络的 IO 消耗，能解释下这个具体是什么意思吗?还有这个跟IO多路复用要解决的问题有什么关系呢？

A: 这是一个非常好的问题，I/O 多路复用的主要作用是让我们可以使用一个线程来**监控多个连接**是否可读或者可写，但是从网络另一头发的数据包需要先解**序列化**成 Redis 内部其他模块可以理解的命令，这个过程就是 Redis 6.0 引入**多线程来并发**处理的。

I/O 多路复用模块**收到数据包之后**将其**丢给后面多个 I/O 线程进行解析**，I/O 线程处理结束后，主线程会负责**串行的执行**这些命令，由于向客户端**发回数据包**的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。

# 参考链接：

- [为什么 Redis 选择单线程模型](https://draveness.me/whys-the-design-redis-single-thread/)
- [评论](https://github.com/draveness/blog-comments/issues/155)

---


- [Redis哨兵、持久化、主从、手撕LRU](https://juejin.im/post/5dc3a9fbf265da4d3c072eab)

## 为啥Redis那么快

- 完全基于内存，绝大部分请求是**纯粹的内存操作**，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
- 数据结构简单，对数据操作也简单，Redis中的**数据结构是专门进行设计**的；
- **采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗**；
- 使用**多路I/O复用模型，非阻塞IO**；
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

## 那他是单线程的，我们现在服务器都是多核的，那不是很浪费？

是的他是单线程的，但是，我们可以通过在单机开多个Redis实例嘛。

> **瓶颈不是CPU，大多都是内存之间的操作。瓶颈是在网络IO**
