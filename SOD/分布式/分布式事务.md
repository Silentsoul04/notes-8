分布式事务是指会涉及到操作多个数据库的事务，其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。

分布式事务处理的关键是：

- 需要记录事务在任何节点所做的所有动作；
- 事务进行的所有操作要么全部提交，要么全部回滚。

# XA 规范

XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供。

二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。

# 定义
二阶段提交的算法思路可以概括为：每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。

所谓的两个阶段分别是：

- 第一阶段：准备阶段（投票阶段）
- 第二阶段：提交阶段（执行阶段）

## 准备阶段

a. 事务询问

协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。

b. 执行事务

各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。

c. 各参与者向协调者反馈事务询问的响应

如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交。

## 提交阶段

a. 发送提交请求

协调者向所有参与者发出commit请求。

b. 事务提交

参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源。

c. 反馈事务提交结果

参与者在完成事务提交之后，向协调者发送Ack信息。

d. 事务提交确认

协调者接收到所有参与者反馈的Ack信息后，完成事务。


# 二阶段提交的优缺点

优点：原理简单，实现方便。

## **缺点**

同步阻塞，单点问题，数据不一致，容错性不好。

### 同步阻塞
在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。

### 单点问题
协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转。更重要的是，其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。

### 数据不一致
假设当协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。这将导致严重的数据不一致问题。

### 容错性不好
如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。

- [分布式理论(三) - 2PC协议](https://juejin.im/post/5b2664446fb9a00e4a53136e)

----

与两阶段提交不同的是，三阶段提交有两个改动点。

- 引入超时机制 - 同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。

# 定义
所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。

- 第一阶段：CanCommit
- 第二阶段：PreCommit
- 第三阶段：Do Commit

## 阶段一：CanCommit

3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

a. 事务询问

协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。

b. 响应反馈

参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。


## 2.2. 阶段二：PreCommit

协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。

### 2.2.1. 执行事务预提交

a. 发送预提交请求

协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。

b. 事务预提交

参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。

c. 各参与者响应反馈

如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。


### 2.2.2. 中断事务

a. 发送中断请求

协调者向所有参与者节点发出 abort 请求 。

b. 中断事务

参与者如果收到 abort 请求或者超时了，都会中断事务。


## 2.3. 阶段三：Do Commit
该阶段进行真正的事务提交，也可以分为以下两种情况。

### 2.3.1. 执行提交

a. 发送提交请求

协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。

b. 事务提交

参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。

c. 响应反馈

事务提交完之后，向协调者发送 ACK 响应。

d. 完成事务

协调者接收到所有参与者的 ACK 响应之后，完成事务。

### 2.3.2. 中断事务

协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。

a. 发送中断请求

协调者向所有参与者发送 abort 请求。

b. 事务回滚

参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。

c. 反馈结果

参与者完成事务回滚之后，向协调者发送 ACK 消息。

d. 中断事务

协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。

# 优缺点

## 优点

相对于二阶段提交，三阶段提交主要解决的**单点故障**问题，并减少了**阻塞**的时间。

因为一旦参与者无法及时收到来自协调者的信息之后，他会**默认执行 commit**。而不会一直持有事务资源并处于**阻塞**状态。

## 缺点

三阶段提交也会导致**数据一致性**问题。由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在**等待超时**之后执行了** commit **操作。

这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。

- [分布式理论(四) - 3PC协议](https://juejin.im/post/5b26648e5188257494641b9f)

> 三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft 算法。

- [浅谈分布式系统一致性之3PC协议](https://mp.weixin.qq.com/s/Ee9FkPcpZ2Hc3-oG559nEw)

> Mysql的二阶段，通过保留状态（xid、undo log）进行故障恢复或者回滚，保证数据一致性。

- [二阶段](./../../mysql/事务日志.md)

---

# eBay 事件队列方案——最终一致性

它的核心思想是将**需要分布式处理的任务通过消息或者日志的方式**来**异步**执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行**失败重试**，它要求各服务的接口是**幂等**的。

论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。

这个方案的核心在于**第二阶段的重试**和**幂等**执行。失败后重试，这是一种**补偿机制**，它是能保证系统最终一致的关键流程。

## 幂等

一般幂等，我会分场景去考虑，看是强校验还是弱校验，比如跟金钱相关的场景那就很关键呀，就做强校验，别不是很重要的场景做弱校验。

### 强校验

比如你监听到用户支付成功的消息，你监听到了去加GMV是不是要调用加钱的接口，那加钱接口下面再调用一个加流水的接口，两个放在一个事务，**成功一起成功失败一起失败**。每次消息过来都要拿着订单号+业务场景这样的唯一标识（比如天猫双十一活动）去流水表查，**看看有没有这条流水**，有就直接return不要走下面的流程了，没有就执行后面的逻辑。

### 弱校验?

这个简单，一些不重要的场景，比如给谁发短信啥的，我就把这个id+场景唯一标识作为Redis的key，放到缓存里面失效时间看你场景，一定时间内的这个消息就去Redis判断。

用KV就算消息丢了可能这样的场景也没关系，反正丢条无关痛痒的通知短信嘛

> 生产环境的例子：支付系统，各个项目组的支付套餐的混合购买。购买后的分布式事务，完成套餐的最终一致性。通过本地数据库来完成本地事务一致性，然后通过异步发送和重试幂等，补偿机制来保证最终一致性。
> 之前的思考，但符合现在的应用场景是，支付与流程引擎（业务系统）之间的分布式事务。支付成功->通知业务->支付状态变更。需要细读论文验证。

---

# TCC （Try-Confirm-Cancel）补偿模式——最终一致性


服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。

Try: 尝试执行业务

    完成所有业务检查（一致性）

    预留必须业务资源（准隔离性）

Confirm: 确认执行业务

    真正执行业务

    不作任何业务检查

    只使用Try阶段预留的业务资源

    Confirm操作满足幂等性

Cancel: 取消执行业务

    释放Try阶段预留的业务资源

    Cancel操作满足幂等性

实现关键要素：

- 服务**调用链**必须被记录下来。
- 每个服务提供者都需要提供一组**业务逻辑相反**的操作，**互为补偿**，同时**回滚操作**要保证**幂等**。
- 必须按失败原因执行**不同的回滚策略**。


Q： 如果有一些意外的情况发生了，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架是如何保证之前没执行完的分布式事务继续执行的呢？

A： 所以，TCC事务框架都是要记录一些分布式事务的活动日志的，可以在磁盘上的日志文件里记录，也可以在数据库里记录。保存下来分布式事务运行的各个阶段和状态。


参考链接：

- [实际的例子](https://juejin.im/post/5bf201f7f265da610f63528a)

> 评论：大厂的分布式事务策略几乎清一色地选择两阶段，极少TCC/没错，tcc很少用，但是，蚂蚁金服大量的用到了tcc事务，还有很多别的公司也是，实际上两阶段最大的问题，就是他的性能比较差

----

# 选型[](#bookmark)
对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的**一致性破坏**，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用**TCC这类分布式事务模型，或基于消息队列的柔性事务框架**，这两种方案都在**业务层实现**，业务开发者具有足够掌控力，可以结合SOA框架来架构，包括Dubbo、Spring Cloud等（题主的标签写了Dubbo）。

- [常用的分布式事务解决方案有哪些?](https://www.zhihu.com/question/64921387/answer/225784480)
- [幂等](https://www.zhihu.com/question/64921387/answer/1023714489)

> 选型简单的对比总结。柔性事务框架应该是成本最低且能保证一致性的。

----
# 优劣对比

横向数据扩展既可以按数据分片扩展，也可以按功能扩展。XA 与 TCC 模型在这一点上的作用类似，都能在横向扩展资源的同时，保证多资源访问的事务属性，只不过前者作用于数据分片时，后者作用于功能扩展时。

基于 XA 协议实现的分布式事务并不能提升热点并发性能，其意义在于**横向扩展资源提升非热点数据并发性能**时，能严格保证对多资源访问的事务 ACID 特性。


XA 模型另外一个意义在于其普适性，抛开性能问题的情况下，几乎可以适用于所有业务模式，这对于一些基础性的技术产品来说是非常有用的，比如分布式数据库、云服务的分布式事务框架等。

TCC 分布式事务模型直接作用于服务层。不与具体的服务框架耦合，与底层 RPC 协议无关，与底层存储介质无关，可以灵活选择业务资源的锁定粒度，减少资源锁持有时间，可扩展性好，可以说是为独立部署的 SOA 服务而设计的。

TCC 的其中一个作用就是在**按照功能横向扩展资源时，保证多资源访问的事务属性**。

TCC 的另一个作用就是把两阶段拆分成了两个独立的阶段，通过资源业务锁定的方式进行关联。资源业务锁定方式的好处在于，既不会阻塞其它事务在第一阶段对于相同资源的继续使用，也不会影响本事务第二阶段的正确执行。

TCC 模型除了跨服务的分布式事务这一层作用之外，还具有两阶段划分的功能，通过业务资源锁定，允许第二阶段的异步执行，而异步化思想正是解决**热点数据并发性能问题的利器之一**。

本文结合具体的业务场景和例子，对比分析了各分布式事务解决方案在性能、热点冲突、接入复杂度和适用场景等方面的能力，希望能帮助各位读者对分布式事务有更深一层的理解。

业务各有各的不同，有些业务能容忍短期不一致，有些业务的操作可以幂等，无论什么样的分布式事务解决方案都有其优缺点，没有一个银弹能够适配所有。因此，业务需要什么样的解决方案，还需要结合自身的业务需求、业务特点、技术架构以及各解决方案的特性，综合分析，才能找到最适合的方案。

- [分布式事务主流解决方案优缺点大pk](https://dbaplus.cn/news-159-1929-1.html)
> 还是得隔段时间后复读，没有很好理解

怎么保证数据一致性的。提交后，个别服务已提交，但是个人服务失去响应。所以协调者需要一个事务管理器，进行重试的机制。事务状态字段来标识事物当前的状态：TRYING, CONFIRMING, CANCELLING。需要保证的状态更改时的一致性，之后的提交或者回滚，该事务id的状态都是一致的，故障后，只是重试完成。

---

- [微服务下数据一致性的几种实现方式](https://mp.weixin.qq.com/s/2fr1gMcOUcwktP1lz_EGcw)

---
# 小结

可以通过简单的mysql的原子性来保证单次执行（分布式锁）与最终一致性？也可以说**通过幂等性来避免分布式锁**。

场景：
`update t1 set a = 2 where a = 1`; 如果是第一次更新，则返回的影响行数是1，可以直接执行下一步。
如果影响行数是0，则代表已经有其他的地方执行了，无须完成下一步。以此实现一个隐藏的锁的操作。

但是这里还是有问题，这里只能保证执行范围内的锁（单次执行），但是无法保证**所有范围内的锁操作**，这样会导致一些问题。
> 数据库的方案也只能解决数据库层面操作的幂等性。

例如更新完成后(a=2)，程序发生了错误。那么重新进入的时候，需要再走下一个流程，则要根据当前状态2进行下一步的操作。如果这一步也是并发的话，那么保证不了这个流程的单次的执行。避免的方案只能是每个调用都是幂等的。数据库的幂等则可以通过上面说的update set where 旧状态限定来保证。

这类比较常见的场景的扣费的时候，需要update t1 set money -= 10 where money > 10;通过以旧状态的数据作为筛选条件，类似版本号的方式，以此避免读写的一致性与锁问题.

---

# 幂等性的解决方案
## 唯一索引
使用唯一索引可以避免脏数据的添加，当插入重复数据时数据库会抛异常，保证了数据的唯一性。

## 乐观锁
这里的乐观锁指的是用乐观锁的原理去实现，为数据字段增加一个version字段，当数据需要更新时，先去数据库里获取此时的version版本号
```select version from tablename where xxx```
更新数据时首先和版本号作对比，如果不相等说明已经有其他的请求去更新数据了，提示更新失败。
```update tablename set count=count+1,version=version+1 where version=#{version}```

## 悲观锁
乐观锁可以实现的往往用悲观锁也能实现，在获取数据时进行加锁，当同时有多个重复请求时其他请求都无法进行操作

## 分布式锁
幂等的本质是分布式锁的问题，分布式锁正常可以通过redis或zookeeper实现；在分布式环境下，锁定全局唯一资源，使请求串行化，实际表现为互斥锁，防止重复，解决幂等。

## token机制
token机制的核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。token机制的应用十分广泛。

- [接口的幂等性](https://juejin.im/post/6894624582091669517): 常见的几个解决办法
