# 工厂方法模式（Factory Method）
工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。
工厂方法把简单工厂的内部判断逻辑移到了客户端代码，本来需要修改工厂类，现在是修改客户端。
简单工厂模式违背了开放-封闭原则，工厂方法模式借助多态，克服了该缺点，却保持了封装对象创建过程的优点。

# 抽象工厂模式（Abstract Factory）
抽象工厂模式：提供一个创建一系列相关或互相依赖对象的接口，只需要知道对象的系列，无需知道具体的对象。
在客户端中，具体工厂类只在初始化时出现一次，更改产品系列即可使用不同产品配置。
利用简单工厂类替换抽象工厂类及其子类，可以使客户端不再受不同系列的影响。
结合反射机制，Assembly.Load(“程序集名称”).CreateInstance(“命名空间”.“类名”)，可以直接通过字符串创建对应类的实例。所有在简单工厂中，都可以通过反射去除switch或if，解除分支判断带来的耦合。
反射中使用的字符串可以通过配置文件传入，避免更改代码。

- [大话设计模式：创建型](http://jennica.space/2016/12/28/design-patterns-creational/)

# 抽象工厂模式
抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

- [抽象工厂模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)

# 个人理解

问题： 客户端需要知道创建什么实例
简单工厂： 将实例抽象，把创建实例的操作细节都放到了工厂里面去实现。客户端进行传参创建。
问题： switch case 导致，因为每增加一种实例，都要在工厂类中增加相应的创建业务逻辑方法，需要新增case，这显然是违背开闭原则的
工厂模式：在简单工厂模式里集中在工厂方法上的压力，可以由工厂方法模式里不同的工厂子类来分担。也就是通过继承达到创建不用的工厂，然后通过统一的create接口，创建不同的实例。
抽象工厂：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 也就是一个抽象工厂，创建一个具体的工厂，工厂创建不同的产品。或者创建另一个具体的工厂，创建跟上一个工厂不一样的产品。



