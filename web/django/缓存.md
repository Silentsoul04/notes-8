# django缓存

标签（空格分隔）： etag

---
## 强制缓存
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

## 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

## 协商缓存生效，返回304，如下
同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

[彻底理解浏览器的缓存机制](https://juejin.im/entry/5ad86c16f265da505a77dca4)
[HTTP 缓存之浏览器刷新行为](https://segmentfault.com/a/1190000010787023)

max-age=0表示不管response怎么设置，在重新获取资源之前，先检验ETag/Last-Modified


# ETAG

### 过程
  tag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下：
====第一次请求===

1. 客户端发起 HTTP GET 请求一个文件；
2. 服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200

====第二次请求===

1. 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d044840
2. 服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；

流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办？
答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.

###作用
Etag 主要为了解决 Last-Modified 无法解决的一些问题。

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
3. 某些服务器不能精确的得到文件的最后修改时间；
为此，HTTP/1.1引入了 Etag(Entity Tags).Etag仅仅是一个和文件相关的标记，可以是一个版本标记,比如说v1.0.0或者说"2e681a-6-5d044840"这么一串看起来很神秘的编码。但是HTTP/1.1标准并没有规定Etag的内容是什么或者说要怎么实现，唯一规定的是Etag需要放在""内。

### 请求头中的 Cache-Control

Cache-Control 不是响应头的专利，即使是从浏览器发起的请求，其头部也可能带有 Cache-Control。请求头中的 Cache-Control 最大的意义是提供一套客户端主动控制代理服务器缓存策略的方案。但由于存在安全风险，实际上目前几乎没有代理服务器实现这个规范。

就像 HTTP 的 PUT 方法上传文件一样，这是存在安全风险的，所以很多服务器并不愿意实现它。

为什么说有安全风险呢？代理服务器上的缓存策略不仅是为了加快访问速度，更重要的一点是保护上游服务，甚至保护更底层的数据库。如果代理服务器的缓存策略暴露给不可信的客户端控制，那么攻击者则可以强行关闭代理服务器的缓存，直接把请求发送到业务服务器上。如果业务服务器到数据库没有缓存或缓存也由下游请求头控制，那么攻击者就可以击穿代理服务器和业务服务器，直接把数据库打爆。

即使是内部服务调用，客户端是可信的。但由于下游服务的开发者并不知道上游服务的获取资源的代价，如果轻易把缓存关掉也会带来隐患。比如上游服务中的某个资源是基于一个慢查询得到的结果，如果下游服务关掉对方的缓存去频繁地刷新这个资源，数据库同样可能被打爆。

所以在某种意义上，客户端请求头中的 Cache-Control 比开启 PUT 方法上传文件还要危险！

但是规范总是太美，总是有人黑着眼眶去实现。比如 Chrome 在开发者工具中勾起 Disable cache 之后，请求头就会被加入一个 Cache-Control:no-cache。然并卵，因为并没有哪个服务器敢实现这个规范。


### django ETAG
  
  可以通过USE_ETAGS = True进行设置，django的USE_ETAGS有在django.middleware.common.CommonMiddleware中间件进行处理但在2.1版本后，会迁移到django.middleware.http.ConditionalGetMiddleware.CommonMiddleware除了加etag还会
Add the Content-Length header to non-streaming responses if not already set.

  ConditionalGetMiddleware的工作功能跟CommonMiddleware会有差异
Handles conditional GET operations. If the response has an ETag or
Last-Modified header, and the request has If-None-Match or
If-Modified-Since, the response is replaced by an HttpNotModified. An ETag header is added if needed.

### 源码
/django/middleware/common.py 的process_response对配置和请求进行判断，看是否要进行etag的缓存
```
        if settings.USE_ETAGS and self.needs_etag(response):
            warnings.warn(
                "The USE_ETAGS setting is deprecated in favor of "
                "ConditionalGetMiddleware which sets the ETag regardless of "
                "the setting. CommonMiddleware won't do ETag processing in "
                "Django 2.1.",
                RemovedInDjango21Warning
            )
            if not response.has_header('ETag'):
                set_response_etag(response)

            if response.has_header('ETag'):
                return get_conditional_response(
                    request,
                    etag=response['ETag'],
                    response=response,
                )
        # Add the Content-Length header to non-streaming responses if not
        # already set.
        if not response.streaming and not response.has_header('Content-Length'):
            response['Content-Length'] = str(len(response.content))

        return response
```
/django/utils/cache.py
而set_response_etag做的就是对内容进行md5生成etag
```
def set_response_etag(response):
    if not response.streaming:
        response['ETag'] = quote_etag(hashlib.md5(response.content).hexdigest())
    return response
```
如果已经有Etag则通过get_conditional_response函数判断是否返回304

解决：暂时还是通过USE_ETAGS进行ETAG的设置？还是直接通过django.middleware.http.ConditionalGetMiddleware进行设置呢？
    

----
/django/middleware/cache.py的UpdateCacheMiddleware对view进行缓存

/django/utils/cache.py的learn_cache_key获取视图的缓存key进行以下操作：

/django/utils/cache.py的_generate_cache_header_key对请求的url和设置的key_prefix组合生成缓存的key，这个key是对设置的vary的header数组（）进行缓存。
```

def _generate_cache_header_key(key_prefix, request):
    """Returns a cache key for the header cache."""
    url = hashlib.md5(force_bytes(iri_to_uri(request.build_absolute_uri())))
    cache_key = 'views.decorators.cache.cache_header.%s.%s' % (
        key_prefix, url.hexdigest())
    return _i18n_cache_key_suffix(request, cache_key)
```

/django/utils/cache.py的_generate_cache_key才是对内容进行缓存
```
def _generate_cache_key(request, method, headerlist, key_prefix):
    """Returns a cache key from the headers given in the header list."""
    ctx = hashlib.md5()
    for header in headerlist:
        value = request.META.get(header)
        if value is not None:
            ctx.update(force_bytes(value))
    url = hashlib.md5(force_bytes(iri_to_uri(request.build_absolute_uri())))
    cache_key = 'views.decorators.cache.cache_page.%s.%s.%s.%s' % (
        key_prefix, method, url.hexdigest(), ctx.hexdigest())
    return _i18n_cache_key_suffix(request, cache_key)
```
流程大致如下：
_generate_cache_header_key对请求的url和设置的key_prefix组合生成缓存的key，用来缓存vary的请求头列表，而_generate_cache_key，则会根据请求头列表，获取请求头的相应数值，加入的key的生成中。当FetchFromCacheMiddleware获取时，先去拿缓存的vary的请求头列表，然后获取request的相应的请求值，生成key，获取缓存。

/django/middleware/cache.py的FetchFromCacheMiddleware获取视图的缓存

```
def get_cache_key(request, key_prefix=None, method='GET', cache=None):
    if key_prefix is None:
        key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX
    cache_key = _generate_cache_header_key(key_prefix, request)
    if cache is None:
        cache = caches[settings.CACHE_MIDDLEWARE_ALIAS]
    headerlist = cache.get(cache_key)
    if headerlist is not None:
        return _generate_cache_key(request, method, headerlist, key_prefix)
    else:
        return None

```