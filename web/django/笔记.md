## [导入的最佳实践](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#imports)

Use absolute imports for other Django components and relative imports for local components.

---
## 配置文件的最佳实践(TODO)

---
## 自定义命令分析

入口是manage.py：django.core.management.execute_from_command_line，然后调用`django.core.management.ManagementUtility`的execute方法，所以:是`ManagementUtility`控制命令调用行为，在ManagementUtility类中python manage.py 就已经调用execute方法获取命令传递的settings的值的并通过django.setup()初始化了， 然后再通过`self.fetch_command(subcommand).run_from_argv(self.argv)`执行子命令, 所以在自定义命令BaseCommand里面更改setting配置的默认值并没有生效.

解决办法： 修改manage.py入口，更改setting路径

---
## connection
工作中纯服务端的项目用到了线程池和django的ORM部分。django 的数据库连接在每一个线程中开启一份，并在查询完毕后自动关闭连接。

使用CONN_MAX_AGE减少数据库请求
这个参数的原理就是在每次创建完数据库连接之后，把连接放到一个Theard.local的实例中。在request请求开始结束的时候，打算关闭连接时会判断是否超过CONN_MAX_AGE设置这个有效期。这是关闭。每次进行数据库请求的时候其实只是判断local中有没有已存在的连接，有则复用。

基于上述原因，Django中对于CONN_MAX_AGE的使用是有些限制的，使用不当，会事得其反。因为保存的连接是基于线程局部变量的，因此如果你部署方式采用**多线程**，必须要注意保证你的最大线程数不会多余数据库能支持的最大连接数。另外，如果使用开发模式运行程序（直接runserver的方式），建议不要设置CONN_MAX_AGE，因为这种情况下，每次请求都会*创建一个Thread*。同时如果你设置了CONN_MAX_AGE，将会导致你创建大量的不可复用的持久的连接。


- https://blog.csdn.net/u010477231/article/details/77576357
- https://www.the5fire.com/reduce-db-conn-with-django-persistent-connection.html

TODO:django runserver 多线程


django.db.close_old_connections：每个请求的开始和结束都会清理无用或者过时的连接。

ConnectionHandler类：相当于django.db.connections。
django/db/utils.py： 通用的不同的数据库配置的各自引擎装载、不同数据库的管理清理与创建。
django/db/utils.py:151：线程local存储数据库连接。
django/db/utils.py:212：这里根据配置获取各个不同的数据库引擎的backend然后创建连接。

关键点：TODO: 打断点试下找到是什么时候创建与销毁连接的，复用么？如何复用的？

BaseDatabaseWrapper的connection是通过close_if_unusable_or_obsolete每次都close了，但是为什么在ConnectionHandler里面能知道，也就是从那里delete_attribute？下一次是在哪里创建的？？
