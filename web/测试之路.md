# 背景

项目中说测试也说很久了，期间也有一段时间专注去进行测试，但最终效果都不是很好。

# 原因

既然这样，为什么不放弃测试呢。我觉得有以下的几点原因：

- 最直接也是最重要的，减少我们的bug的出现。这里的bug我也觉得有几个方面。
  - 新需求。就是直接写的新功能的，原因大概可能无法覆盖到一些边界条件导致的。
  - 旧逻辑。这种就是经历最多的了，改了一处代码，莫名其妙影响了其他的逻辑代码，导致错误异常。
  - 重构。项目没有很好的工程规范与实践，技术方案也是赶鸭子。导致经常重构，重构总是浪费各种时间进行旧代码逻辑的校验检查。
- 改变写代码的思路。虽然说看过一些TDD，但也没有真正悟道。但之前写的测试其实对自身代码的架构、分层还是会有很大的帮助的。带领我们用另一个角度去思考编程。
  - 外部接口或者某一方面的mock，会让你在测试的时候，会思考如何根据特性进行聚合管理，文件放置结构等，怎么样才能更好进行测试的书写，其实也使我们的代码更有条理清晰。
  - 测试用例的书写，会让你写代码的时候，会思考这个函数是否不够解耦，会不会放了太多参数或者依赖逻辑进去，导致测试用例很难书写。
  - 各种外部依赖。会让我们去想，如何在测试的时候，进行绕过，中间件设计的时候是否需要进行这样的考虑解耦。其实同样的思路，也是能方便我们本地开发，一举两得。例子就是测试的时候，是否应该可以放过权限，测试的时候可以不用把所有的流程都构建成功。其实这个也涉及到我们用例和代码的思考、如何设计（自我仍需要多多思考总结）
  - 测试数据的生成。脱离数据库的固有思想的约束，各种数据和依赖都是能无中生有的。这样的思想也不仅仅适用于测试。其他的工作需求也是类似的，例如压测，例如前后端联调。
  
这些都能让我们打破固有的思维约束，提高自身的编码能力和思维。也能提高我们的工程规范与流程，提高我们工作的开发效率。

# 难点

工作中的一些体会：

- 数据库依赖
- 外部服务
- 测试流程

## 数据库依赖

数据服务项目，最大的问题应该是数据库的表和数据究竟是怎么来的？经历了几个阶段

1. django的测试表的生成。思路其实是根据django的文档介绍来的，通过ORM生成相关的数据库表。期间也遇到了些挫折，因为对原生的ORM做了一些魔改，导致测试表的生成会发生原生model和项目自身的model冲突的问题。最后通过禁用原生表的创建和代码脱离原生model的依赖进行解决的。基础也是因为没有用到原生用户和权限的太多功能（思考：不要太依赖框架本身）

2. 随着项目发展，数据中台的接入。有了统一了的数据仓库，各个库与表都能比较好的约束和录入。以此在CI/CD上自动化构建了各个数据库的镜像。也能构建公用的ORM代码。数据库镜像的构建不仅简化了自身测试的流程，也能在CI/CD中支持各种数据校验和测试，也方便了本地开发测试的时候数据库的迅速构建。

## 外部服务

自从项目开始微服务后，单体的代码拆成了5、6个代码仓库。其中的一些服务还得彼此依赖，导致写测试的时候发现整个测试流程比较复杂。

思考了一下，觉得有几个点需要注意一下的：

1. mock外部服务。对于Python这样的动态语言，可以直接通过TestCase的直接拦截patch掉外部服务，然后进行定制的返回。对于go，java等静态语言，就比较需要注意了，需要做一些依赖注入。但python搞成这样，我觉得是得不偿失的。

2. mock服务应该怎么写？这里没想得太好，现在的做法就是测试需要什么数据就伪造一下。这样会不会到最后相当于把整个项目的逻辑实现了？

3. mock服务部署。不单单是一个项目会用到该服务的mock，其他项目也会用到。所以不应该由写用例的代码去写mock（现在的做法），应该是由服务自身提供相应的mock数据返回。暂时想到做法的思路有：

- 定义好接口的文档，通过API工具生成mock。例如：最近使用接触到的yapi工具。不仅能使接口更可阅读，也可以通过高级mock，返回定制需要的数据。
  - 这样做的好处是，统一接口的流程与规范，随着接口的更改，其测试用例、数据也必须做相应的更改和维护。避免现在经常会出现的情况：频繁更改后，测试用例难以追踪，也无法跟上，导致废弃，并反而造成工作负担。
  - 坏处，我觉得可能是mock数据的伪造成本。会不会依赖工具，不够灵活，最后被迫自己定制。
  
- 服务自身设计的时候考虑上提供mock服务。其他项目可以简单通过构建其mock镜像进行提供服务。
  - 好处。服务自身业务，理解方便，快速、灵活构成mock。并且更改代码后也能快速做成更改。
  - 坏处。可能就是如何脱离服务自身的依赖，并顺利完成自身的mock。上面其实也是有同样的问题，简单来说就是mock数据的生成。

- 之前的一个思路是独立一个mock的代码仓库。整合所有需要的依赖，独立到该项目里，实现各自的mock逻辑。但我觉得脱离了自身的服务，后续维护很难，成本也太高了。虽然录入，管理更方便了。

# 测试流程

测试流程是因为测试的工程规范没有接触过，只是摸石头过河。

阶段一。所有的数据表都在本地数据库通过ORM创建起来，也就是django文档的那一套。其中比较方便的好处就是方便调试了。

阶段二。CI上跑，数据库依赖原生的Mysql镜像进行构建，通过ORM进行创建相关的表格，其实跟阶段一差不多，只是数据库换成了镜像启动。其中遇到的问题就是数据库的设置不相符（时区、group by）导致的用例错误，也很好更改了相关的代码逻辑写法。

阶段三。我觉应该就是依赖于中台构建的数据库镜像与上面所说的外部服务的mock（yapi、服务自身的mock）。不管是CI上，或者本地上都应该脱离各种依赖，简单来说就是能够通过docker-compose能完成完整的测试流程。也在以此为目标实践中。
