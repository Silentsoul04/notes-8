---
# time wait

在web00上看到很多time wait

今天测试了一下，用requests的session就可以解决这个问题 https://2.python-requests.org/en/v2.8.1/user/advanced/

---
# 为什么Go的web框架速度还不如Java

https://www.zhihu.com/question/360929863/answer/980246776

首先呢，Java也是编译型的语言。Java的编译分为两个步骤，第一步是从源代码到bytecode，也就是.class文件。我们日常看到的java jar包，其实就是bytecode的分发形式。第二步是在运行时，java虚拟机会和jit合作，把bytecode在需要的时候编译成native code。所以说呢，你这个链接里的跑分比较，其实大家跑的都是编译后的native code。

其次，web框架不单单要看中对语言的执行效率，还要看IO的效率。当然这也没什么花头，java的很多框架和go的异步IO如出一辙, 说白了还是借助linux操作系统中的epoll等来减少进程堵塞。于是很多跑分中，语言的执行效率变得次要，在充分优化和合理使用nonblocking IO的情况下，一些解释型语言也能取得很好的成绩。

最后，也是最重要的，其实你看这些跑分，框架的性能都好的不行不行的，远远超过一般应用的需要。其实在实际应用中，我们的业务逻辑会更复杂，上下游服务也会更多，其实就算是好多人瞧不起的增删改查操作，并发大了也极容易产生性能瓶颈。换句话说，编程语言和框架本身是不容易成为性能瓶颈的。所以，**我建议应该更多的从开发难易程度，以及以后项目长期维护的成本上来选择语言和框架，而不是看跑分**。

> 实际应用做，业务会更复杂。觉得不看重的增删改查，并发大了，也是有性能问题的。从开发难易程度，以及以后项目长期维护的成本上来选择语言和框架，而不是看跑分


[阿里巴巴淘系技术](https://www.zhihu.com/question/360929863/answer/1650981553)

第三点 prefork ， java netty 等是直接对于线程操作，可以更加定制化的优化性能，而 go 的 goroutine 需要的是一个通用协程，目的是降低编写并发程序的难度，在这个层次上难免性能比不上一个优化的非常出色的 Java 基于线程操作的框架；但是直接操作线程的话需要合理控制好线程数，这是个比较头疼的调优问题(特别是对于新手来说)，而 goroutine 则可以不关心池子的大小，使得代码更加优雅和简洁，这对于工程质量保障其实是一个提升。另外这里存在 prefork 是由于 go 没法直接操作线程，而 fasthttp 提供了 prefork 的能力，使用多进程方式来对标 Java 的多线程来进一步提高性能。

