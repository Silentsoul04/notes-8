栈是限定在一端进行插入与删除的线性表，允许插入与删除的一端称为栈顶，不允许插入与删除的另一端称为栈底。栈按照“先进后出”(FILO)或“后进先出”(LIFO)组织数据，栈具有记忆作用

------------------------------------------------------------------------------------------

虚拟存储器的最大容量=min(计算机字长，内存容量和硬盘容量之和) 
------------------------------------------------------------------------------------------
传说中鸵鸟看到危险就把头埋在地底下。当你对某一件事情没有一个很好的解决方法时，那就忽略它，就像鸵鸟面对危险时会把它深埋在沙砾中，装作看不到。这样的算法称为“鸵鸟算法“。 我还以为鸵鸟算法就是看到他死锁了也不管他呢。。。

鸵鸟策略、预防策略、避免策略、检测与解除死锁。 
------------------------------------------------------------------------------------------

引入缓冲的主要目的：
1．缓和处理机和I/O设备间速度不匹配的矛盾
2．减少对CPU的中断次数
3．提高CPU和I/O设备之间的并行性

------------------------------------------------------------------------------------------
森林的遍历：① 前序遍历一棵树恰好等价于前序遍历该树对应的二叉树
    　② 后序遍历树恰好等价于中序遍历该树对应的二叉树。
http://student.zjzk.cn/course_ware/data_structure/web/shu/shu6.5.3.htm
------------------------------------------------------------------------------------------
二叉树的左右子树不可任意交换;深度为K的完全二叉树的结点个数小于或等于深度相同的满二叉树 
------------------------------------------------------------------------------------------
脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。 

丢失修改。
这两个事务的问题出在，原本两个事务的目的是T1先把A的值加10，A变为110,。然后T2把A的值再减10，即A变回100。
但是根据题目中的执行顺序，A的值变为90，即T2的修改覆盖了T1的修改，这种现象叫做丢失修改。


------------------------------------------------------------------------------------------

与Mysql服务器相互作用的通讯协议包括TCP/IP，Socket，共享内存，命名管道



MySQL实现了四种通信协议

    TCP/IP协议，通常我们通过来连接MySQL，各种主要编程语言都是根据这个协议实现了连接模块
    Unix Socket协议，这个通常我们登入MySQL服务器中使用这个协议，因为要使用这个协议连接MySQL需要一个物理文件，文件的存放位置在配置文件中有定义，值得一提的是，这是所有协议中最高效的一个。
    Share Memory协议，这个协议一般人不知道，肯定也没用过，因为这个只有windows可以使用，使用这个协议需要在配置文件中在启动的时候使用–shared-memory参数，注意的是，使用此协议，一个host上只能有一个server，所以这个东西一般没啥用的，除非你怀疑其他协议不能正常工作，实际上微软的SQL Sever也支持这个协议
    Named Pipes协议，这个协议也是只有windows才可以用，同shared memory一样，使用此协议，一个host上依然只能有一个server，即使是使用不同的端口也不行，Named Pipes 是为局域网而开发的协议。内存的一部分被某个进程用来向另一个进程传递信息，因此一个进程的输出就是另一个进程的输入。第二个进程可以是本地的（与第一个进程位于同一台计算机上），也可以是远程的（位于联网的计算机上）。正因为如此，假如你的环境中没有或者禁用TCP/IP环境，而且是windows服务器，那么好歹你的数据库还能工作。使用这个协议需要在启动的时候添加–enable-named-pipe选项 

------------------------------------------------------------------------------------------

新建一个管理员用户admin,需要使用的参数() useradd -u 0 -o admin
-u 用户号 指定用户的用户号；因为系统用户的用户号为0，故指定用户号为0 如果同时有-o选项，则可以重复使用其他用户的标识号；因为系统本身存在用户号为0的系统用户，故应该使用该参数。 
------------------------------------------------------------------------------------------
存储过程
declare表示声明，@表示赋值。
------------------------------------------------------------------------------------------
c++中规定，重载运算符必须和用户定义的自定义类型的对象一起使用。 
------------------------------------------------------------------------------------------
依次把结点的关键字的值为50,30,20,150,130,40,80,70,85,15的记录插入到初始化为空的平衡二叉排序树中,在插入过程中平衡树条件如被破坏,则进行必要的调整,得到的平衡二叉排序树的深度为() 
n+1对2取对数，结果向上取整， 


------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------
 线程和进程资源比较

进程占有的资源
	

线程占有的资源

地址空间 
全局变量 
打开的文件 
子进程 
信号量 
账户信息
	

栈 
寄存器 
状态 
程序计数器 

------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------

嵌入式 C 里面比较少用除法和取余数，是因为很多 MCU 做除法或取余数消耗的指令周期非常多。所以才会出现很多用位操作的优化，比如 x >>= 1 ，表示 x = x/2 。

------------------------------------------------------------------------------------------
-2^16 ~ 2^16 -1 
16位最大正整数为 7fff	0111 1111 1111 1111
最小负整数为 8000	1000 0000 0000 0000	-(1000 0000 0000 0000)		-32768

这得从二进制的原码说起：
如果以最高位为符号位，二进制原码最大为0111111111111111=2的15次方减1=32767
最小为1111111111111111=-2的15次方减1=-32767
此时0有两种表示方法，即正0和负0：0000000000000000=1000000000000000=0
所以，二进制原码表示时，范围是-32767～-0和0～32767，因为有两个零的存在，所以不同的数值个数一共只有2的16次方减1个，比16位二进制能够提供的2的16次方个编码少1个。
但是计算机中采用二进制补码存储数据，即正数编码不变，从0000000000000000到0111111111111111依旧表示0到32767，而负数需要把除符号位以后的部分取反加1，即-32767的补码为1000000000000001。
到此，再来看原码的正0和负0：0000000000000000和1000000000000000，补码表示中，前者的补码还是0000000000000000，后者经过非符号位取反加1后，同样变成了0000000000000000，也就是正0和负0在补码系统中的编码是一样的。但是，我们知道，16位二进制数可以表示2的16次方个编码，而在补码中零的编码只有一个，也就是补码中会比原码多一个编码出来，这个编码就是1000000000000000，因为任何一个原码都不可能在转成补码时变成1000000000000000。所以，人为规定1000000000000000这个补码编码为-32768。
所以，补码系统中，范围是-32768～32767。
因此，实际上，二进制的最小数确实是1111111111111111，只是二进制补码的最小值才是1000000000000000，而补码的1111111111111111是二进制值的-1。

------------------------------------------------------------------------------------------



常见文件系统 系统函数

    fcntl  文件控制  
    open  打开文件  
    creat  创建新文件  
    close  关闭文件描述字  
    read  读文件  
    write  写文件  
    readv  从文件读入数据到缓冲数组中  
    writev  将缓冲数组里的数据写入文件  
    pread 对文件随机读  
    pwrite  对文件随机写 

------------------------------------------------------------------------------------------

 #include <ctype.h>

定义函数：

int isupper(int c);

函数说明：检查参数c是否为大写英文字母。

返回值：若参数c 为大写英文字母，则返回非 0，否则返回 0。

头文件：

#include <ctype.h>

islower() 用来判断一个字符是否是小写字母，其原型为：

  int islower(int c);

for(i = 0; str[i] != 0; i++)
    if(islower(str[i]))
      printf("%c is a lower-case character\n", str[i]);
}



c2=c1+32;               //将大写的转换成小写的

------------------------------------------------------------------------------------------
套接字借口 socket interface
简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程

应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口。 

区分不同应用程序进程间的网络通信和连接，主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。Socket原意是 “插座”。通过将这3个参数结合起来，与一个“插座”Socket绑定，**应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 **
------------------------------------------------------------------------------------------
API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。
rsa 大数分解问题

------------------------------------------------------------------------------------------
代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联(OSI)模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接INTERNET（国际互联网）和Local Area Network（局域网）。
代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存了的资源。

防火墙的两种类型：
一、分组路由中的过滤 主要是运输层和网络层
二、代理服务器 应用层
------------------------------------------------------------------------------------------
##VPN代理
指在共用网络上建立专用网络的技术。之所以称为虚拟网主要是因为整个VPN网络的任意两个结点之间的连接并没有传统专网建设所需的点到点的物理链路，而是架构在公用网络服务商ISP所提供的网络平台之上的逻辑网络。用户的数据是通过ISP在公共网络（Internet）中建立的逻辑隧道（Tunnel），即点到点的虚拟专线进行传输的。通过相应的加密和认证技术来保证用户内部网络数据在公网上安全传输，从而真正实现网络数据的专有性。[1]  
------------------------------------------------------------------------------------------
##密钥分配?
------------------------------------------------------------------------------------------
##负载均衡

负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。


------------------------------------------------------------------------------------------
##反向代理
通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须**指定**代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。

由于外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对Internet上多个客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器**不支持外部对内部网络的访问请求**。

###当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。

此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。

例子：http://zhidao.baidu.com/link?url=m5o9PaNfq7f4h34Eft70o59El0N3a0uL_t3vW4BS2xKViKJ4pP6a8moRso7XDamzRuvgmU2cAf1PFXTFrqTNGWh369S20-XctZeQMrk1e5O

如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何 URL，然后再将消息发送给客户机。
(可以理解代理服务器是一个双向的代理服务器？)

安全反向代理 当代理服务器与其他机器之间有一个或多个连接使用安全套接字层(SSL) 协议加密数据时，即会进行安全反向代理。
------------------------------------------------------------------------------------------
##CDN
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置**反向代理节点服务器**所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
------------------------------------------------------------------------------------------
##SDK
软件开发工具包（外语首字母缩写：SDK、外语全称：Software Development Kit）一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。
软件开发工具包广义上指辅助开发某一类软件的相关文档、范例和工具的集合。
------------------------------------------------------------------------------------------
##DLL，
即 Dynamic Link Library（动态链接库）。在windows环境下含有大量 .dll格式的文件，这些文件就是动态链接库文件，其实也是一种可执行文件格式。跟 .exe 文件不同的是，.dll文件不能直接执行，他们通常由 .exe 在执行时装入，内含有一些资源以及可执行代码等。
SDK 包含了使用 API 的必需资料，所以人们也常把仅使用 API 来编写 Windows 应用程序的开发方式叫做“SDK编程”。

------------------------------------------------------------------------------------------
##xss（http://www.cnblogs.com/wangyuyu/p/3388180.html）

可以通过html代码把浏览器的cookie发出去

跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。

XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。


**正如上文所说，如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。Django 内置模版和 Jinja2 模版总是默认转义输出变量的。**
------------------------------------------------------------------------------------------
##CSRF（http://www.cnblogs.com/wangyuyu/p/3388180.html）

###个人理解：用户在危险网站的请求下，带着安全网站的cookie去发出坏的请求。攻击者并没有获得第三方的cookie.拥有cookie是指浏览器端拥有cookie。

一、 CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。

二、CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 **XSS** 或链接欺骗等途径，让用户在本机（**即拥有身份 cookie 的浏览器端**）发起用户所不知道的请求。


三、跨站请求伪造保护

CSRF 中间件和模板标签提供对跨站请求伪造简单易用的防护。某些恶意网站上包含链接、表单按钮或者JavaScript ，它们会利用登录过的用户在浏览器中的认证信息试图在你的网站上完成某些操作，这就是跨站攻击。还有另外一种相关的攻击叫做“登录CSRF”，攻击站点触发用户浏览器用其它人的认证信息登录到其它站点。

多窗口浏览器（firefox、遨游、MyIE……）便捷的同时也带来了一些问题，因为多窗口浏览器新开的窗口是具有当前所有会话的。
具有其他窗口的cookie
###防范措施
1. 对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。（相当于令牌token）

2. 另一个可选的方法是“双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form post之前正被JavaScript代码读取，那么限制跨域规则将被应用。什么叫限制跨域规则呢？限制跨域规则就是：如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。


首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。当然，最理想的做法是使用 REST 风格 的 API 设计，GET、POST、PUT、DELETE 四种请求方法对应资源的读取、创建、修改、删除。

攻击者已经不可能通过发布链接来伪造请求了，但他们仍可以发布表单，或者在其他站点上使用我们肉眼不可见的表单，在后台用 js 操作，伪造请求。

(http://www.django-china.cn/topic/580/)


(1).Cookie Hashing(所有表单都包含同一个伪随机值)：
实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token）， 保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登陆验证身份。

!!**这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:>**!!


这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢....由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。


(2).验证码
(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)


最后的疑问：究竟真的不能获取到第三方的cookie么？

------------------------------------------------------------------------------------------
參數化查詢（Parameterized Query或Parameterized Statement）是指在設計與資料庫連結並存取資料時，在需要填入數值或資料的地方，使用參數（Parameter）來給值，這個方法目前已被視為最有效可預防SQL注入攻击的攻擊手法的防禦方式。

除了安全因素，相比起拼接字符串的SQL语句，参数化的查询往往有性能优势。因为参数化的查询能让不同的数据通过参数到达数据库，从而公用同一条SQL语句。大多数数据库会缓存解释SQL语句产生的字节码而省下重复解析的开销。如果采取拼接字符串的SQL语句，则会由于操作数据是SQL语句的一部分而非参数的一部分，而反复大量解释SQL语句产生不必要的开销。
------------------------------------------------------------------------------------------
##unix网络编程中将IO模型分为5类：阻塞IO，非阻塞IO，IO复用，信号驱动，异步IO。

    阻塞IO就是那种recv, read，一直等，等到有了数据才返回；
    非阻塞IO就是立即返回，设置描述符为非阻塞，但是要进程自己一直检查是否可读；
    IO复用其实也是阻塞的，不过可以用来等很多描述符，比起阻塞有了进步，可以算有点异步了，但需要阻塞着检查是否可读。对同一个描述符的IO操作也是有序的。
    信号驱动采用信号机制等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的IO操作还是有序的。
    异步IO，发送IO请求后，不用等了，也不再需要发送IO请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，你等到的通知也不再是要求你去读写IO了，而是告诉你IO请求过程已经结束了。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。(对应上面那个买书例子中，就是送书到我家，我直接看书就行了，不需要再去跑一趟了)。

其中IO服用和信号驱动，在处理业务逻辑上可以说有异步，但在IO操作层面上来说还是同步的。

https://www.zhihu.com/question/19732473/answer/14413599


------------------------------------------------------------------------------------------
##wsgi
PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标。

##CGI

CGI即通用网关接口(Common Gateway Interface)，是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。

------------------------------------------------------------------------------------------
##rest

------------------------------------------------------------------------------------------
辅助空间为o(1)的意思。
行算法时必须要的空间,其大小的数量级为1,换句话说该算法所需的辅助
空间不依赖算法的规模.

------------------------------------------------------------------------------------------
API应该被设计成无状态的（Stateless）。这意味着没有登陆，注销的方法，也没有sessions，API的设计者同样也不能依赖Cookie，因为不能保证这些request是由浏览器所发出的。自然，我们需要一个新的机制。这篇文章关注于JSON Web Tokens，简写为JWTs，一个可能的解决这个问题的机制。这篇文章利用Node的Express框架作为后端，以及Backbone作为前端。

------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------

谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”
