
# 目录结构
- 认识目录结构，明确好各个目录作用与界限

# 脚本模板
- 同一姿势？

# 日志
- 存储所有的原始日志，入库失败能重复消费。

# 注释规范
- 统一规范，注释过于冗余？
- ci可以添加检查注释填写，类型检查，生成文档

# requests
- 统一requests的client，状态码统一判断，错误异常处理，重试机制，请求限流器

# celery
- 统一celery请求姿势

# 异常处理
- 少try，抛出去，统一处理异常
- 预期错误warning，超过某个阈值处理。外部不可预期error，应该是有一个就需要解决一个。
- 禁止print=》logger.info

# 单元测试
- 爬到的各种case作为测试用例，覆盖到每一行，写这行是为了覆盖哪个测试用例

# 数据库
- 入库都是时间戳，业务自行处理时区问题
- 封装入库姿势，不用管怎么入数据库，load data 还是bulk insert。也可以解耦换数据库底层引擎。 

# 代码逻辑
- 关注结构复杂度，而不是长度复杂度。可以没必要拆成很多函数，但不能有太多嵌套判断逻辑
- pylint有复杂度的检查



---
# ES

es 集群问题。ES的写入是要保证所有副本完成吗？

ES的Bouncing results问题， 是因为同样的数据，但是节点顺序不同导致的？而不是不同的数据导致的。


---
# 配置的最佳实践

环境变量？如何版本控制？

https://12factor.net/config

为什么要改成环境变量：
线上配置文件是直接拷贝的问题, 项目加配置不能兼容之前的配置. 最近逐步改成基于环境变量加载吧.


---
# 去自增id以提高性能

？： 不同素材相同digest的内容入库也会有丢失的问题. 彻底解决需要将关联id全部替换成digest的方式完成, 但会导致额外的冗余
为什么替换就能解决digest？额外的冗余是啥意思？

？： id基于k1,k2生成会导致潜在的数据丢失, 但是不会覆盖已有数据
没能理解

？： 通过全局自增id的方式来处理不能做到重复消费得到相同的输出, 且仍需要额外维护唯一索引保证？
通过唯一索引来进行区分是否已经入库？已得到相同的输出？

？： 当然更好的办法是现在整个数据链条关系, 尽量去范式, ID的数据类型能够更长.
去范式，也就是不是分表的，全仍一个表。而且保证唯一主键足够长



肯定是不能用全局自增id的算法的（类似雪花的），无法保持同样的约束得到相同的输出。
通过hash获取，需要解决碰撞问题，性能问题：每次都hash、后面碰撞越多，解决碰撞越耗性能？

方案cache_get：
封装`select id from tbl where uniq_field1=... and uniq_field2=...`
如何优化？


---

- [ ] 如何在redash上支持分表的整合语句查询？

`table_name = "kwranks_%s_%s_%s" % (year, week, app_id_md5[-2:])`

---
