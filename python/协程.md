协程，又称微线程，纤程。英文名Coroutine。

## 优势

看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

- 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

- 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。


## gevent

Gevent是一个基于Greenlet实现的网络库，通过greenlet实现协程。基本思想是一个greenlet就认为是一个协程，当一个greenlet遇到IO操作的时候，比如访问网络，就会自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO操作。


```python

import gevent

def test(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        # gevent.sleep(1)

if __name__ == '__main__':
    g1 = gevent.spawn(test, 3)
    g2 = gevent.spawn(test, 3)
    g3 = gevent.spawn(test, 3)
    
    g1.join()
    g2.join()
    g3.join()

```

可以看到3个greenlet是依次运行而不是交替运行。要让greenlet交替运行，可以通过gevent.sleep()交出控制权

当然在实际的代码里，我们不会用gevent.sleep()去切换协程，而是在执行到IO操作时gevent会自动完成，所以gevent需要将Python自带的一些标准库的运行方式由阻塞式调用变为协作式运行。这一过程在启动时通过monkey patch完成

```python
from gevent import monkey; monkey.patch_all()
```

- [Python协程详解](https://juejin.im/post/5d888151f265da03dd3db0f5)

---

## selectors
## python 协程 底层

---
# 谈Python协程技术的演进

## 同步编程
同步编程的改进方式有多进程、多线程，但对于 c10k 问题都不是良好的解决方案，多进程的方式存在操作系统可调度进程数量上限较低，进程间上下文切换时间过长，进程间通信较为复杂。

而 Python 的多线程方式，由于存在众所周知的 GIL 锁，性能提升并不稳定，仅能满足成百上千规模的 I/O 密集型任务，多线程还有一个缺点是由操作系统进行抢占式调度存在竞态条件，可能需要引入了锁与队列等保障原子性操作的工具。

## 异步编程

它的作用是将大量的文件描述符托管给内核，内核将最底层的 I/O 状态变化封装成读写事件，这样就避免了由程序员去主动轮询状态变化的重复工作，程序员将回调函数注册到 epoll 的状态上，当检测到相对应文件描述符产生状态变化时，就进行函数回调。

对事件集合进行轮询，调用回调函数等,一轮事件循环结束，循环往复。

EventLoop屏蔽了进行epoll系统调用的具体操作。对于用户来说，将不同的I/O状态考量为事件的触发，只需关注更高层次下不同事件的回调行为。诸如libev, libevent之类的使用C编写的高性能异步事件库已经取代这部分琐碎的工作。


### python框架
在**Python框架**里一般会见到的这几种事件循环：
- libevent/libev: Gevent(greenlet+前期libevent，后期libev)使用的网络库，广泛应用；
- tornado: tornado框架自己实现的IOLOOP；
- picoev: meinheld(greenlet+picoev)使用的网络库，小巧轻量，相较于libevent在数据结构和事件检测模型上做了改进，所以速度更快。但从github看起来已经年久失修，用的人不多。
- uvloop: Python3时代的新起之秀。Guido操刀打造了asyncio库，asyncio可以配置可插拔的event loop，但需要满足相关的API要求，uvloop继承自libuv，将一些低层的结构体和函数用Python对象包装。目前Sanic框架基于这个库

## 协程


EventLoop简化了不同平台上的事件处理，但是处理事件触发时的回调依然很麻烦，响应式的异步程序编写对程序员的心智是一项不小的麻烦。
因此，协程被引入来替代回调以简化问题。协程模型主要在在以下方面优于回调模型：

以近似同步代码的编程模式取代异步回调模式，真实的业务逻辑往往是同步线性推演的，因此，这种同步式的代码写起来更加容易。底层的回调依然是callback hell，但这部分脏活累活已经转交给编译器与解释器去完成，程序员不易出错。
异常处理更加健全，可以复用语言内的错误处理机制，回调方式。而传统异步回调模式需要自己判定成功失败，错误处理行为复杂化。
上下文管理简单化，回调方式代码上下文管理严重依赖闭包，不同的回调函数之间相互耦合，割裂了相同的上下文处理逻辑。协程直接利用代码的执行位置来表示状态，而回调则是维护了一堆数据结构来处理状态。
方便处理并发行为，协程的开销成本很低，每一个协程仅有一个轻巧的用户态栈空间。


## EventLoop与协程的发展史

近十年以来，后端领域内古老的子例程与事件循环得到结合，协程(协作式子例程)快速发展，并也革新与诞生了一些语言，比如 golang 的 goroutine，luajit 的 coroutine，Python 的 gevent,erlang 的 process，scala 的 actor 等。

就不同语言中面向并发设计的协程实现而言，Scala 与 Erlang 的 Actor 模型、Golang 中的 goroutine 都较 Python 更为成熟，不同的协程使用通信来共享内存，优化了竞态、冲突、不一致性等问题。然而，根本的理念没有区别，都是在用户态通过事件循环驱动实现调度。

由于历史包袱较少，后端语言上的各种异步技术除 Python Twisted 外基本也没有 callback hell 的存在。其他的方案都已经将 callback hell 的过程进行封装，交给库代码、编译器、解释器去解决。

## Gevent
Gevent 基于 Greenlet 与 Libev，greenlet 是一种微线程或者协程，在调度粒度上比 PY3 的协程更大。greenlet 存在于线程容器中，其行为类似线程，有自己独立的栈空间，不同的 greenlet 的切换类似操作系统层的线程切换。

## 总结
从 Python 语言发展的角度来说，async/await 并非是多么伟大的改进，只是引进了其他语言中成熟的语义，协程的基石还是在于 eventloop 库的发展，以及生成器的完善。从结构原理而言，asyncio 实质担当的角色是一个异步框架，async/await 是为异步框架提供的 API，因为使用者目前并不能脱离 asyncio 或其他异步库使用 async/await 编写协程代码。即使用户可以避免显式地实例化事件循环，比如支持 asyncio/await 语法的协程网络库 curio，但是脱离了 eventloop 如心脏般的驱动作用，async/await 关键字本身也毫无作用。

- [谈谈Python协程技术的演进](https://segmentfault.com/a/1190000012291369)

---
# 协程源码

asyncio.unix_events._UnixSelectorEventLoop: Unix event loop.Adds signal handling and UNIX Domain Socket support to SelectorEventLoop.
asyncio.unix_events._UnixDefaultEventLoopPolicy：UNIX event loop policy with a watcher for child processes.
asyncio.unix_events._UnixSelectorEventLoop.create_unix_server: 创建socket
asyncio.selector_events.BaseSelectorEventLoop._start_serving: epoll事件注册与启动

