Q: MySQL Engine 有哪些, InnoDB存储引擎的特点

A: 
1. MyISAM: 该存储引擎存储占用的空间相对与InnoDB存储引擎来说会少很多，但其支持的为表锁，其并发性能会低很多，而且不支持事务，通常只应用于只读模式的应用。它是MySQL最原始的存储引擎。
2. InnoDB：支持事务操作(如 begin， commit，rollback命令)，支持行级锁，行级锁相对于表锁，其粒度更细，多版本并发控制,允许并发量更大, 支持AUTO_INCREMENT, 支持外键。缺点是读写效率较差，占用的数据空间相对较大。


### Innodb特性

#### 插入缓存

当一个表有非聚集索引时，对于非聚集索引的叶子节点的插入不是顺序的，这时候需要离散的访问非聚集索引页，性能就在这里降低了，这是由于b+树的原理导致的。插入缓存就是用来解决这个问题的。

对于非聚集索引的插入和更新操作，不是每一次都直接插入索引页，而是先判断插入的非聚集索引页是否在缓存中，如果在就直接插入，如果不在就放入到一个插入缓冲区中，好似欺骗数据库这个非聚集索引已经插入到叶子节点了。然后再以一定的频率插入缓存和非聚集索引页字节点的合并操作。

插入缓存的使用需要满足以下两个条件(也就是非唯一的辅助索引)：索引是辅助索引；索引不是唯一的。

#### 两次写

原因： 重做日志会损坏。

两次写给innodb带来的是可靠性，主要用来解决部分写失败(partial page write)。在应用重做日志之前，我们需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。

> doublewrite页的副本是连续的，doublewrite buffer中的页写入各个表空间文件，此时的写入则是离散的

doublewrite有两部分组成，一部分是内存中的doublewrite buffer，大小为2M，另外一部分就是物理磁盘上的共享表空间中联系的128个页，即两个区，大小同样为2M。当缓冲池的张也刷新时，并不直接写硬盘，而是回通过memcpy函数将脏页先拷贝到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次写，每次写入1M到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。



#### 自适应哈希索引
由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了 adaptive hash index功能，innodb存储引擎会监控对表上索引的查找，如果观察到建立hash索引可以提高性能的时候，则自动建立hash索引。

#### 预读（？）
为提高读取性能，InnoDB采用预读取方式将所需数据读入内存，包括随机预读取 random read ahead 和线性预读取 linear read ahead。从innodb plugin 1.0.4开始，随机访问预读被关闭了，因为经常引起性能问题。但是线性预读还是保留了，并且加入了innodb_read_ahead_threshold参数。默认是56，也就是说如果一个区的56个页都被访问过，且访问模式是顺序的，那么预读下一个区中所有的页。

- [预读](https://idlesummerbreeze.wordpress.com/2014/09/09/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/)

#### 异步IO
比如用户发出了一条索引扫描的查询，那么这条sql可能扫描多个索引页，也就是需要进行多次IO操作，在每扫描一个页并等待其结束才能扫描下一个页，这是没有必要的，异步IO就是用户发出一个IO请求后可以立即发出下一个请求，所有请求发送完毕后等待所有IO操作的完成，这就是AIO。

异步 IO：InnoDB 中，read ahead(预读) 方式的读取时通过 AIO 完成的，脏页的刷新也是通过 AIO 完成的。

#### 刷新领接页
当刷新一个临近页时，会检测改页所在的区是否由别的脏页，若有则放入一个 IO 操作刷新。这样做的好处是可以将多次IO操作合并为一个IO。